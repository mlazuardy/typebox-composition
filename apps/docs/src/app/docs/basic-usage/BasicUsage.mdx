# Basic Usage

As we mentioned in the [Overview](/docs), type composition aimed to validate incoming data either from form input or within your HTTP Requests.

## Writing Schema / Rules

First, make sure you have create an `TypeComposition` instance that we mentioned in the [Installation Guide](/docs/installation).

Then create a schema / rules.

```ts
import { Type } from "@sinclair/typebox";

const schema = Type.Object({
  name: Type.String({ minLength: 8, maxLength: 50 }),
});
```

After that you can validate the using this schema from your incoming data using `.validate` method

```ts
import { type Static } from "@sinclair/typebox";
import { validator } from "./your-type-composition-instance";
// assumed you passed incoming data within this function
export function createUser(data: Static<typeof schema>) {
  const { errors } = validator.validate(schema, data);

  if (errors.length) {
    // errors will return Array-object with pre-formatted messages based on your `TypeComposition` options
  }

  // validation passed, creating user.
}
```

As you can see in the example above, if validation fails, we can check if `errors.length` is more than one.
- If you're using validation within backend like express, fastify etc. you can send the errors as well as error status `422`.
- in Browser / client like React, Vue etc. You can update your errors state and conditionally return the error component / tag.

If validation fails, the `errors` will return like this:

```json
[
  {
    field: "name",
    kind: "String",
    path: "/name",
    message: "the name field is required.",
  },
]
```

| Property  | Description |
| ------------- | ------------- |
| field  | Field that you've defined in your schema  |
| kind  | Typebox or custom type kind |
| path  | Typebox path, if schema is nested it will return /path/:nestedPath/:and so on  |
| message | pre-formatted message, or plain message if we dont covered the Type |
